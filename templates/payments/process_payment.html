{% extends 'base.html' %}
{% load static %}

{% block title %}FreshCart - Process Payment{% endblock %}

{% block extra_head %}
    <!-- Stripe.js v3 -->
    <script src="https://js.stripe.com/v3/"></script>
{% endblock %}

{% block content %}
<main class="container mx-auto py-8 px-4">
    <h1 class="text-4xl font-bold text-gray-800 mb-8">Complete Your Payment</h1>

    <div class="bg-white rounded-lg shadow-md p-6 max-w-lg mx-auto">
        <h2 class="text-2xl font-bold text-gray-800 mb-4">Order #{{ order.id }}</h2>
        <p class="text-lg text-gray-700 mb-6">Amount Due: <span class="font-bold text-cyan-700">â‚¹{{ order.get_total_cost }}</span></p>

        {# Store client_secret and publishable_key in data attributes #}
        <div id="payment-element"
             data-publishable-key="{{ stripe_publishable_key | escapejs }}"
             data-client-secret="{{ client_secret | escapejs }}">
            <!-- Stripe will inject the Payment Element here -->
        </div>
        <button id="submit-payment" class="btn-primary bg-cyan-600 text-white py-3 px-8 rounded-full font-semibold shadow-md w-full mt-6">
            Pay Now
        </button>
        <div id="payment-message" class="message-box hidden mt-4"></div>
    </div>
</main>
{% endblock %}

{% block extra_js %}
<script>
    const submitButton = document.getElementById('submit-payment');
    const paymentMessage = document.getElementById('payment-message');
    const paymentElementContainer = document.getElementById('payment-element');
    let stripe;
    let elements;
    let paymentElement;

    // Read keys from data attributes
    const publishableKey = paymentElementContainer.dataset.publishableKey;
    const clientSecret = paymentElementContainer.dataset.clientSecret;

    console.log("Stripe Publishable Key (from data-attribute):", publishableKey); // For debugging
    console.log("Stripe Client Secret (from data-attribute):", clientSecret); // For debugging

    try {
        // Basic validation for Stripe.js and keys
        if (typeof Stripe === 'undefined') {
            throw new Error("Stripe.js v3 is not loaded. Please check your network connection or ad blockers.");
        }
        if (!publishableKey || publishableKey === 'None' || publishableKey.trim() === '') {
            throw new Error("Stripe Publishable Key is missing or invalid in settings.");
        }
        if (!clientSecret || clientSecret === 'None' || clientSecret.trim() === '') {
            throw new Error("Stripe Client Secret is missing or invalid. PaymentIntent was not created correctly on the server.");
        }

        stripe = Stripe(publishableKey);
        // Initialize elements with the clientSecret obtained on page load
        elements = stripe.elements({ clientSecret: clientSecret });
        paymentElement = elements.create('payment');
        paymentElement.mount('#payment-element');

    } catch (e) {
        console.error("Error initializing Stripe:", e.message);
        if (paymentMessage) {
            paymentMessage.classList.remove('hidden');
            paymentMessage.classList.add('error');
            paymentMessage.textContent = 'Payment system error: ' + e.message;
        }
        if (submitButton) {
            submitButton.disabled = true;
        }
    }

    // Only add event listener if Stripe was successfully initialized and clientSecret is available
    if (stripe && submitButton && clientSecret) {
        submitButton.addEventListener('click', async () => {
            paymentMessage.classList.add('hidden');
            paymentMessage.classList.remove('success', 'error');
            paymentMessage.textContent = '';
            submitButton.disabled = true; // Disable button to prevent multiple clicks

            try {
                // 1. First, submit the Payment Element to collect and validate details
                const { error: submitError } = await elements.submit();

                if (submitError) {
                    // Show error from element submission
                    paymentMessage.classList.remove('hidden');
                    paymentMessage.classList.add('error');
                    paymentMessage.textContent = submitError.message;
                    submitButton.disabled = false; // Re-enable button
                    return; // Stop execution if there's a submission error
                }

                // 2. If element submission is successful, then confirm the PaymentIntent
                const { error: confirmError } = await stripe.confirmPayment({
                    elements,
                    clientSecret, // Use the clientSecret already available
                    confirmParams: {
                        return_url: window.location.origin + "{% url 'orders:order_history' %}", // Redirect after success
                    },
                });

                if (confirmError) {
                    // Show error from payment confirmation
                    paymentMessage.classList.remove('hidden');
                    paymentMessage.classList.add('error');
                    paymentMessage.textContent = confirmError.message;
                } else {
                    // Payment succeeded, but the redirect to return_url will handle the success message.
                    // This block might not be reached if return_url is set.
                }
            } catch (e) {
                // This catch block handles network errors or other unexpected client-side issues
                paymentMessage.classList.remove('hidden');
                paymentMessage.classList.add('error');
                paymentMessage.textContent = 'An unexpected error occurred during payment processing.';
                console.error('Payment processing error:', e);
            } finally {
                submitButton.disabled = false; // Re-enable button in case of client-side error
            }
        });
    }
</script>
{% endblock %}
